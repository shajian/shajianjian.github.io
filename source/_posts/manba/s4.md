---
title: Efficiently Modeling Long Sequences with Structured State Spaces
date: 2024-11-15 17:15:31
tags: manba
mathjax: true
---

[论文](https://arxiv.org/2111.00396/abs)

[代码](https://github.com/state-spaces/s4)

时序模型中如何处理具有长文依赖的数据？尽管传统的模型包括 RNN, CNN 以及 Transformer 通过特殊的变体捕获长上下文依赖，但是在超长序列例如 10000 或者更多 steps 时仍然显得艰难。最近的一些有希望的方法是根据 state space model(SSM) 建模，然而现有的基于 SSM 的模型存在计算量大以及内存占用高等问题。本文提取 Structured State Space (S4) sequence model，也是基于 SSM，解决了计算瓶颈。

# 1. 背景：状态空间

## 2.1 SSM

SSM 可表示为

$$x'(t) = Ax(t) + Bu(t) \\\\ y(t)=Cx(t) + Du(t) \tag{1}$$

这是连续状态空间模型，其中 $u(t)$ 表示 t 时刻的输入，$x(t)$ 表示系统的隐状态，$x'(t)$ 表示隐状态改变的速率， $y(t)$ 是系统的输出。这几个变量的维度可以不相同。

因为 $Du$ 可以看作是 skip connection，这很容易计算，故为了简单期间，我们忽略 (1) 式中的 $D$，即，令 $D=0$。

## 2.2 HiPPO

之前的一些工作已经发现 SSM 的性能并不好，这是因为 (1) 式的解是指数方程，在长序列时会导致梯度呈指数变化，从而出现梯度消失/爆炸 问题。为了解决这个问题，$A$ 使用 HiPPO 矩阵。HiPPO 矩阵如下：

$$A_{nk}=-\begin{cases}(2n+1)^{1/2} (2k+1)^{1/2} & n > k \\\\ n+1 & n=k \\\\ 0 & n < k\end{cases} \tag{2}$$

## 2.3 离散 SSM

为了能应用到离散输入序列上，需要将 (1) 式离散化。记时间步长为 T（其实习惯应该写为 $\Delta$，但是这个字母输入较复杂，故使用 T 代替），那么 k 时间步的输入就是 $u_k = u(kT)$。离散化 (1) 式后得到

$$\begin{aligned} x_k &= \overline A x _ {k-1} + \overline B u _ k  & \overline A = (I - T/2 \cdot A) ^{-1} (I + T / 2 \cdot A) 
\\\\ y_k &= \overline C x _ k & \overline B  = (I - T/2 \cdot A) ^ {-1} T B, \quad \overline C = C
\end{aligned} \tag{3}$$

<details>
<summary>(3) 式推导过程</summary>

以下部分内容参考 [知乎文章](https://zhuanlan.zhihu.com/p/680534665)

在离散时间系统中，我们需要考虑每个时间步长内，状态变化的累积量，即 $x _ {k+1} - x _ k$，所以对 (1) 式的常微分方程积分，得到

$$x(t)=x(0) + \int _ t ^ t (A x(\tau) + B u(\tau)) d \tau \tag{4}$$

(4) 式中积分项中含有 $x(\tau)$，这是未知的，所以无法积分。解决思路：构造一个新的函数 $\alpha(t)x(t)$，目的是为了使得这个新函数的导数中不含有 $x(t)$，这样就可以对新函数的导数积分，得到新函数，从而得到 $x(t)$。

对 $\alpha(t) x(t)$ 求导，

$$\begin{aligned}\frac d {dt} [\alpha(t)x(t)] &= \frac {d \alpha(t)} {dt} x(t) + \alpha(t) \frac {d x(t)}{dt}
\\\\ &=\frac {d \alpha(t)} {dt} x(t) + \alpha(t) [A x(t) + B u(t)]
\\\\ &=[\frac {d \alpha(t)} {dt} + \alpha(t)A] x(t) + \alpha(t)Bu(t)
\end{aligned} \tag{5}$$

要使得新函数的导数中没有 $x(t)$，那么

$$\frac {d \alpha(t)} {dt} + \alpha(t)A=0 \tag{6}$$

解 (6) 式，得 

$$\alpha(t) = e ^ {-At} \tag{7}$$

代入 (5) 式得，

$$\frac d {dt} [e ^ {-At}x(t)] =e^{-At}Bu(t) \tag{8}$$

对 (8) 式积分得

$$e ^ {-At} x(t) = x(0) + \int _ 0 ^ t e ^ {-A\tau} B u(\tau) d \tau \tag{9}$$

整理得

$$x(t) = e ^ {At} x(0) + \int _ 0 ^ t e ^ {A(t-\tau)} B u(\tau) d\tau \tag{10}$$

(10) 式是从 0 到 t 的积分，为了得到离散形式，我们改为从 $t _ k$ 到 $t _ {k+1}$ 的积分，

$$x(t _ {k+1}) = e ^ {A(t _ {k+1} - t _ k)} x(t _ k) + \int _ {t_k} ^{t_{k+1}} e ^ {A(t _ {k+1} - \tau)} B u(\tau) d\tau \tag{11}$$

时间步长 $T = t_{k+1} - t_k$，并假设 $u(t)$ 在 $[t_k, t_{k+1})$ 区间是恒定的（零阶保持），那么 (11) 式为

$$x(t_{k+1})=e ^{AT} x(t_k) + \int _ {t_k}^{t_{k+1}} e ^ {A(t_{k+1}-\tau)}d\tau B u(t_k) \tag{12}$$

由于 $u$ 在积分外面，那么可以令 $\sigma = (t _ {k+1} - \tau) \in [0, T]$，(12) 式变为

$$x(t_{k+1})=e ^{AT} x(t_k) + \int _ 0 ^ T e ^ {A \sigma} d\sigma B u(t_k)\tag{13}$$

其中，

$$\begin{aligned} \int _ 0 ^ T e ^ {A \sigma} d\sigma&=\int _ 0 ^ T (I + A \sigma + \frac 1 {2!}A^2 \sigma ^ 2 + \cdots) d\sigma
\\\\ &=IT + \frac 1 {2!}AT^2 + \frac 1 {3!}A^2 T^3 + \cdots
\\\\ &=A^{-1}(e ^{AT}-I)\end{aligned} \tag{14}$$

(14) 式中，第一个等式用到了指数函数的泰勒展开，第二个等式则是对每一项单独积分再求和，第三个等式同样是利用了指数函数的泰勒展开，代入 (13) 式得，

$$x(t_{k+1})=e ^{AT} x(t_k) + A^{-1}(e ^{AT}-I) B u(t_k)\tag{15}$$

根据 z 变换有，

$$e^{sT}=\frac {e^{sT/2}}{e^{-sT/2}}\approx \frac {1+sT/2}{1-sT/2} \tag{16}$$

(16) 中第二个等式用到了指数函数的泰勒一阶展开。将 (16) 式代入 (15) 式，(3) 式得证。
</details>

(3) 式使得离散 SSM 可以像 RNN 那样计算，$x_k \in \mathbb R^N$ 是隐态，对应的转移矩阵为 $\overline A$。

## 2.4 训练 SSM

由于 (3) 式按序列依次计算，这使得训练较慢，需要将 (3) 式写成离散卷积形式。

为了方便，令初态为 $x_{-1}=0$，那么展开 (3) 式得，

$$\begin{matrix} x_0 = \overline B u _ 0 & x _ 1 = \overline {AB} u_0 + \overline B u_1 & x_2 = \overline A ^ 2 \overline B u_0 + \overline {AB}u_1 + \overline B u_2 & \cdots
\\\\ y_0 = \overline {CB} u_0 & y_1=\overline {CAB}u_0 +\overline {CB}u_1 & y_2=\overline {CA}^2 \overline B u_0 + \overline {CAB}u_1 + \overline {CB} u_2 & \cdots
\end{matrix}$$

归纳得到下式，

$$\begin{aligned} y_k &= \overline {CA} ^ k \overline B u_0 + \overline {CA} ^ {k-1} \overline B u_1 + \cdots + \overline {CAB} u_{k-1} + \overline {CB} u_k
\\\\ y &= \overline K \star u
\end{aligned} \tag{17}$$

其中卷积核为

$$\overline K \in \mathbb R^L := \mathcal K _ L(\overline A, \overline B, \overline C):=(\overline {CA}^i \overline B)_{i \in [L]}=(\overline {CB}, \overline {CAB}, \ldots, \overline {CA}^{L-1} \overline B) \tag{18}$$

这里输入序列长度为 $L$ 即 $u, \overline K \in \mathbb R^L$。根据 (17) 式以及卷积的定义有，

$$y_k = \sum_{t=-\infty}^{+\infty} \overline K (t)u(k-t)$$

由于 $t, k-t \in [0, L)$，所以 $t\in [0, k]$，根据上式可得 (17) 式中的 $y_k$ 的展开式。在序列长度较长即 $L$ 较大时，卷积计算也比较慢（需要计算 $y_k$ $L$ 次），可以通过 FFT 加快计算。

<details>
<summary>卷积计算通过 FFT 提速的原理</summary>

卷积定义： $(f \star g)(t)=\int _{-\infty}^{+\infty} f(\tau) g(t-\tau) d\tau$

傅里叶变换定义：$F(f)=\mathcal F\{f(t)\}=\int_{-\infty}^{+\infty} f(t) e ^{-j2\pi ft} dt$

这里 $F(f)$ 表示傅里叶变换后的函数其自变量为 $f$ 表示频率，而 $f(t)$ 是原函数其自变量为 $t$ 表示时间，注意这两者的区别。$\mathcal F \{f(t)\}$ 表示对 $f(t)$ 做傅里叶变换。

卷积性质：两个函数在时域（或位置空间）的卷积的傅里叶变换等于它们在频域中的乘积，即

$$\mathcal F\{f\star g\}=\mathcal F\{f\} \cdot \mathcal F\{g\}=F(f) \cdot G(f)$$

上式省略了时域函数 $f$ 和 $g$ 的自变量 $t$，并使用 $F$ 和 $G$ 表示傅里叶变换后的函数，其频率自变量为 $f$，注意需要根据上下文区分 $f$ 的含义。

证明：

根据傅里叶变换和卷积的定义有

$$\begin{aligned} \mathcal F\{f\star g\} &= \int _ {-\infty}^{+\infty} \left(\int _ {-\infty}^{+\infty} f(\tau) g(t-\tau) d\tau \right) e ^{-j2\pi ft} dt
\\\\ &=\int _ {-\infty}^{+\infty} f(\tau) \left(\int _ {-\infty}^{+\infty} g(t-\tau) e ^{-j2\pi ft} dt \right) d\tau
\\\\ & \stackrel{v=t-\tau}=\int _ {-\infty}^{+\infty} f(\tau) \left(\int _ {-\infty}^{+\infty} g(v)e^{-j2\pi f \cdot (v+\tau)} dv\right)d\tau
\\\\ &=\int _ {-\infty}^{+\infty} f(\tau) \left(\int _ {-\infty}^{+\infty} g(v)e^{-j2\pi fv} dv\right)e^{-j2\pi f\tau} d\tau
\\\\ &=\int _ {-\infty}^{+\infty} f(\tau)  e^{-j2\pi f\tau} d\tau \cdot G(f)
\\\\ &=F(f) \cdot G(f)
\end{aligned}$$

快速计算卷积步骤：

1. 使用 FFT 将信号从时域转到频域
2. 在频域中 element-wise 相乘
3. 使用 i-FFT 将结果转到时域

直接卷积的时间复杂度为 $O(N^2)$，而 FFT 的时间复杂度为 $O(N \log N)$，那么对于长信号，使用 FFT 可以提高卷积计算速度。

计算 (17) 式中的卷积 $y=\overline K \star u$，使用 FFT 加速的伪码如下，

```python
k = np.random.randn(L)  # 卷积核即 \overline K
u = np.random.randn(L)  # 输入序列
N = len(K) + len(u) - 1
U = np.fft.fft(x, N)
K = np.fft.fft(k, N)
Y = K * X   # element-wise 乘积
y = np.fft.ifft(Y)      # 
```

</details>

但是，计算 (18) 式中的 $\overline K$ 是非凡的（non-trivial），本文第 `# 3` 节考虑如何计算 SSM 卷积核 $\overline K$。

# 3. 方法：S4

本节讨论如何高效地计算 SSM 的参数：连续型表示 $(A,B,C)$，循环型表示 $(\overline A, \overline B, \overline C)$ 和卷积核 $\overline K$。

## 3.1 对角化

计算 $\overline K$ 的瓶颈在于多个重复的矩阵 $\overline A$ 的连乘。

__Lemma 3.1__  SSM（由 $(A,B,C)$ 表征） 的共轭具有等价关系： $(A,B,C) \sim (V^{-1} AV, V^{-1}B, CV)$

证明：

分别给出 SSM 关于状态 $x$ 和 $\tilde x$ 的表示，

$$\begin{matrix} x'=Ax+Bu & \tilde x'=V^{-1}AV\tilde x + V^{-1}Bu
\\\\ y = Cx & y = CV\tilde x
\end{matrix}$$

以上两种 SSM 可通过 $x =V \tilde x$ 变换，本质是相同的，相当于对隐态 $x$ 作了一次基变换，故 Lemma 3.1 得证。

Lemma 3.1 通过共轭变换将矩阵 $A$ 变换到规范形式，例如 $A$ 是对角矩阵，那么 (5) 式计算则变得可处理，然而简单地应用对角化依然行不通，这是因为数据计算问题。验证
HiPPO 矩阵的对角化，其元素值按状态空间的维度 $N$ 的指数增长，导致数值计算问题，例如 $N=256$，那么 $2^{4N/3}>2^{341}$ 超出 float32 的范围了。

__Lemma 3.2__ HiPPO 矩阵 $A$ (2) 式 根据矩阵 $V_{ij}=\begin{pmatrix}i+j \\\\ i-j \end{pmatrix}$ 进行对角化。特别地，$V_{3i,i}=\begin{pmatrix}4i \\\\ 2i \end{pmatrix} \approx 2 ^ {4i}$，因此 $V$ 中元素值的幅度高达 $2^{4N/3}$ 。

<details>
<summary>Lemma 3.2 证明</summary>

第一步：

(2) 式的 HiPPO 矩阵可共轭相似于以下矩阵，即 

$$A=\overline P^{-1} A_{HiPPO} P \tag{19}$$

其中 $A$ 的元素值为

$$A_{nk}=\begin{cases}(-1)^{n-k} (2k+1) & n > k\\\\ k+1 & n=k \\\\ 0 & n < k\end{cases} \tag{20}$$

且 $P$ 是对角矩阵，记 $P_{ii}=a_i + b_i j$，$\overline P$ 是 $P$ 的共轭矩阵 $\overline P_{ii}=a_i-b_i j$。

证明 (19) 式成立。我们先假设 (19) 式成立，如果能解出 $P$，那么得证。

根据 (19) 式有，

$$\begin{aligned}A_{nk}&=\sum_m (\overline P^{-1} A_{HiPPO})_{nm} P_{mk}
\\\\&=(\overline P^{-1} A_{HiPPO})_{nk} P_{kk}
\\\\&=\left(\sum_m \overline P_{nm}^{-1} (A_{HiPPO})_{mk}\right)P_{kk}
\\\\&=\overline P_{nn}^{-1} (A_{HiPPO})_{nk} P_{kk}
\end{aligned} \tag{21}$$

上式推导中，由于 $P$ 和 $\overline P$ 的非对角项均为 0，即 $m\ne k$ 时 $P_{mk}=0$，当 $m\ne n$ 时，$\overline P_{nm}=0$。

根据 (2) (20) 和 (21) 式，可得

1. $n=k$ 时
    
    $$n+1=\frac 1 {a_n -b_n j} (-n-1)(a_n+b_n j)\Rightarrow a_n+b_n j=-a_n+b_n j$$

    于是有

    $$a_n=0, \quad i=0,\ldots, N-1 \tag{22}$$

2. $n>k$ 时

    $$(-1)^{n-k} (2k+1)=(-b_n j)^{-1}[-(2n+1)^{1/2} (2k+1)^{1/2}](b_k j)$$

    上式化简得，其中用到 $(-1)^{n-k}=(-1)^{k-n}$，

    $$b_n=(-1)^{n-k}\frac {\sqrt {2n+1}}{\sqrt {2k+1}}b_k \tag{23}$$

    假设固定 $k=0$ 时的值 $b_0$，那么 

    $$b_n=(-1)^n \sqrt{2n+1} b_0, \quad n=1,\ldots, N-1$$

故 (19) 式成立，对角矩阵为

$$P_{nn}=(-1)^n \sqrt{2n+1} b_0, \quad n=0,1,\ldots, N-1  \tag{24}$$

其中 $b_0$ 为任意非 0 值。

第二步：证明上述矩阵 $A$ 可以使用如下矩阵进行对角化，

$$V=\begin{pmatrix} i+i \\\\ i-j \end{pmatrix}_{ij}=\begin{bmatrix}1 \\\\ 1 & 1 \\\\ 1 & 3&1\\\\ 1&6&5&1\\\\ \vdots&&&& \ddots\end{bmatrix} \tag{25}$$

此证明过程见论文附录 B。

根据等式 $2^n = \sum _ {k=0}^n C_n ^k$，其中最大的项为 $C _ n ^ {\lfloor n /2 \rfloor}$，令 $n=4i$，于是

$$\begin{pmatrix}4i \\\\ 2i\end{pmatrix} = C_{4i}^{2i} \approx 2^{4i}$$

因为矩阵 $V$ 维度为 $N \times N$，所以当 $i=N/3$ 时有最大元素幅值 $|V_{N,N}| \approx 2^{4N/3}$ 。

</details>

## 3.2 S4 参数化：规范加低秩

通过上一节的分析知道，对角矩阵 $V$ 元素幅值呈指数增长，使得无法数值计算，那么一个很自然的想法就是，使用酉矩阵进行对角化，酉矩阵 $U$ 满足 $U^{†} U=I$，其中 $U^{†}$ 是 $U$ 的共轭转置。

根据线性代数的光谱理论，正规矩阵可以被酉矩阵对角化。正规矩阵是指一个矩阵 $A$ 与其共轭转置矩阵可交换，即 $AA^{†}=A^{†}A$ 。

然而 HiPPO 矩阵并非正规矩阵。作者发现尽管 HiPPO 矩阵非正规，但是它可以分解为一个正规矩阵和一个低秩矩阵的和，不过这种分解依然无法快速计算 (18) 式，也难以优化。作者使用以下方法解决这个问题。


__定理 1：__ 所有的 HiPPO 矩阵有 NPLR（Normal Plus Low-Rank） 表示，即

$$A=V\Lambda V^{\star}-PQ^{\top}=V(\Lambda - (V^{\star}P)(V^{\star}Q)^{\star})V^{\star}$$

其中 $V^{\star}, Q^{\top}$ 分别表示共轭转置和转置，$V \in \mathbb C^{N\times N}$ 表示酉矩阵，$\Lambda$ 为对角矩阵，$P,Q \in \mathbb R^{N \times r}$ 表示低秩矩阵，对于 HiPPO-LegS, LegT, LagT，有 $r=1$ 或者 $r=2$。


